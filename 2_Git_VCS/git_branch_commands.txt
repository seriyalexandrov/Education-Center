1) Создаем ветку локально, сразу же переключаемся на нее, а затем загружаем в удаленный репозиторий. 
	На самом деле, лучше сначала создать ветку удаленно, а затем выгрузить. Но тем не менее:

	git checkout -b <имя ветки>
	git push 
	
2) Смержить изменения из branchA в branchB. branchA останется неизменной.

	git checkout branchA (переключаемся на branchA)
	git pull             (затягиваем свежие изменения)
	git checkout branchB
	git merge branchA    (смержить изменения из branchA в branchB)
	
	Если удался автоматический мерж, то будет предложено ввести сообщение, которое пометит коммит, 
	в котором смержены ветки.
	Если возникили конфликты, то сначала нужно разрешить их, зайдя в каждый конфликтующий файл, 
	а затем вручную сделать коммит, как обычно.
	Для разрешения конфликтов можно использовать специальный редактор для мержа изменений с помощью команды:
	
	git mergetool
	
3) Посмотреть, как ветки выглядят визуально:

	gitk --all (отображаются все ветки)
	gitk <имя ветки 1> <имя ветки 2> ... (только нужные ветки)
	
4) Rebase изменений. По своей сути аналог merge. Немного сложнее в использовании и в выстраивании
	процесса, зато позволяет поддерживать линейную историю. 
	Лично я пока что всегда пользуюсь merge, т.к. дешево и сердито. 
	Rebase используется, чтобы коммиты из одной ветки применить последовательно к дургой ветке. 
	Выполним коммиты ветки branchA в конце ветки branchB:

	git checkout branchA
	git rebase -i branchB
	
	Если столкнулись с конфликтами, решаем их с помощью 
	
	git mergetool
	
	И продолжаем rebase:
	
	git rebase --continue
	git checkout branchB
	git merge branchA --ff-only
	
5) Получам список бренчей стпометкой в какой мы ветке сейчас:
	git branch (если хотим сортировать по дате последних коммитов добавляем --sort=-committerdate) 
